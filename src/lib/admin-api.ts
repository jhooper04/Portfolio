//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AuthorizedApiBase {
    private readonly config: ApiConfig;

    protected constructor(config: ApiConfig) {
        this.config = config;
    }

    protected transformOptions = (options: RequestInit): Promise<RequestInit> => {
        options.headers = {
            ...options.headers,
            Authorization: this.config.getAuthorization(),
        };
        return Promise.resolve(options);
    };
}

export class Client extends AuthorizedApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: ApiConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    assetsUpload(siteId?: number | undefined, body?: AssetRequest | undefined): Promise<AssetResponse> {
        let url_ = this.baseUrl + "/assets?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAssetsUpload(_response);
        });
    }

    protected processAssetsUpload(response: Response): Promise<AssetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssetResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    assetsGetAllFolders(siteId?: number | undefined): Promise<FolderResponse[]> {
        let url_ = this.baseUrl + "/assets?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAssetsGetAllFolders(_response);
        });
    }

    protected processAssetsGetAllFolders(response: Response): Promise<FolderResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FolderResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FolderResponse[]>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @param siteId (optional) 
     * @return Success
     */
    assetsList(pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, siteId?: number | undefined): Promise<AssetResponsePaginatedList> {
        let url_ = this.baseUrl + "/assets/all?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAssetsList(_response);
        });
    }

    protected processAssetsList(response: Response): Promise<AssetResponsePaginatedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetResponsePaginatedList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssetResponsePaginatedList>(null as any);
    }

    /**
     * @param folderId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @param siteId (optional) 
     * @return Success
     */
    assetsGetByFolder(folderId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, siteId?: number | undefined): Promise<AssetResponsePaginatedList> {
        let url_ = this.baseUrl + "/assets/folder?";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAssetsGetByFolder(_response);
        });
    }

    protected processAssetsGetByFolder(response: Response): Promise<AssetResponsePaginatedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetResponsePaginatedList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssetResponsePaginatedList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    assetsGetById(id: number, siteId?: number | undefined): Promise<AssetResponse> {
        let url_ = this.baseUrl + "/assets/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAssetsGetById(_response);
        });
    }

    protected processAssetsGetById(response: Response): Promise<AssetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssetResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    assetsUpdate(id: number, siteId?: number | undefined, body?: AssetRequest | undefined): Promise<AssetResponse> {
        let url_ = this.baseUrl + "/assets/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAssetsUpdate(_response);
        });
    }

    protected processAssetsUpdate(response: Response): Promise<AssetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssetResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    assetsDelete(id: number, siteId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/assets/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAssetsDelete(_response);
        });
    }

    protected processAssetsDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    categoriesCreate(siteId?: number | undefined, body?: CategoryResponse | undefined): Promise<CategoryRequest> {
        let url_ = this.baseUrl + "/categories?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCategoriesCreate(_response);
        });
    }

    protected processCategoriesCreate(response: Response): Promise<CategoryRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryRequest>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return Success
     */
    categoriesList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined): Promise<CategoryResponsePaginatedList> {
        let url_ = this.baseUrl + "/categories?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCategoriesList(_response);
        });
    }

    protected processCategoriesList(response: Response): Promise<CategoryResponsePaginatedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryResponsePaginatedList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryResponsePaginatedList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    categoriesGetById(id: number, siteId?: number | undefined): Promise<CategoryResponse> {
        let url_ = this.baseUrl + "/categories/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCategoriesGetById(_response);
        });
    }

    protected processCategoriesGetById(response: Response): Promise<CategoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    categoriesUpdate(id: number, siteId?: number | undefined, body?: CategoryRequest | undefined): Promise<CategoryResponse> {
        let url_ = this.baseUrl + "/categories/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCategoriesUpdate(_response);
        });
    }

    protected processCategoriesUpdate(response: Response): Promise<CategoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    categoriesDelete(id: number, siteId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/categories/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCategoriesDelete(_response);
        });
    }

    protected processCategoriesDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    messagesSend(siteId?: number | undefined, body?: MessageRequest | undefined): Promise<MessageResponse> {
        let url_ = this.baseUrl + "/messages/send?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMessagesSend(_response);
        });
    }

    protected processMessagesSend(response: Response): Promise<MessageResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessageResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return Success
     */
    messagesList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined): Promise<MessageResponsePaginatedList> {
        let url_ = this.baseUrl + "/messages?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMessagesList(_response);
        });
    }

    protected processMessagesList(response: Response): Promise<MessageResponsePaginatedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageResponsePaginatedList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessageResponsePaginatedList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    messagesDelete(id: number, siteId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/messages/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMessagesDelete(_response);
        });
    }

    protected processMessagesDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    postsCreate(siteId?: number | undefined, body?: PostRequest | undefined): Promise<PostResponse> {
        let url_ = this.baseUrl + "/posts?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostsCreate(_response);
        });
    }

    protected processPostsCreate(response: Response): Promise<PostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return Success
     */
    postsList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined): Promise<PostResponsePaginatedList> {
        let url_ = this.baseUrl + "/posts?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostsList(_response);
        });
    }

    protected processPostsList(response: Response): Promise<PostResponsePaginatedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponsePaginatedList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostResponsePaginatedList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    postsGetById(id: number, siteId?: number | undefined): Promise<PostResponse> {
        let url_ = this.baseUrl + "/posts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostsGetById(_response);
        });
    }

    protected processPostsGetById(response: Response): Promise<PostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    postsUpdate(id: number, siteId?: number | undefined, body?: PostRequest | undefined): Promise<PostResponse> {
        let url_ = this.baseUrl + "/posts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostsUpdate(_response);
        });
    }

    protected processPostsUpdate(response: Response): Promise<PostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    postsDelete(id: number, siteId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/posts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostsDelete(_response);
        });
    }

    protected processPostsDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    projectsCreate(siteId?: number | undefined, body?: ProjectRequest | undefined): Promise<ProjectResponse> {
        let url_ = this.baseUrl + "/projects?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processProjectsCreate(_response);
        });
    }

    protected processProjectsCreate(response: Response): Promise<ProjectResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return Success
     */
    projectsList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined): Promise<ProjectResponsePaginatedList> {
        let url_ = this.baseUrl + "/projects?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processProjectsList(_response);
        });
    }

    protected processProjectsList(response: Response): Promise<ProjectResponsePaginatedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectResponsePaginatedList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectResponsePaginatedList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    projectsGetById(id: number, siteId?: number | undefined): Promise<ProjectResponse> {
        let url_ = this.baseUrl + "/projects/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processProjectsGetById(_response);
        });
    }

    protected processProjectsGetById(response: Response): Promise<ProjectResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    projectsUpdate(id: number, siteId?: number | undefined, body?: ProjectRequest | undefined): Promise<ProjectResponse> {
        let url_ = this.baseUrl + "/projects/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processProjectsUpdate(_response);
        });
    }

    protected processProjectsUpdate(response: Response): Promise<ProjectResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    projectsDelete(id: number, siteId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/projects/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processProjectsDelete(_response);
        });
    }

    protected processProjectsDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitesCreate(body?: SiteRequest | undefined): Promise<SiteResponse> {
        let url_ = this.baseUrl + "/sites";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSitesCreate(_response);
        });
    }

    protected processSitesCreate(response: Response): Promise<SiteResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SiteResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SiteResponse>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return Success
     */
    sitesList(pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined): Promise<SiteResponsePaginatedList> {
        let url_ = this.baseUrl + "/sites?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSitesList(_response);
        });
    }

    protected processSitesList(response: Response): Promise<SiteResponsePaginatedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SiteResponsePaginatedList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SiteResponsePaginatedList>(null as any);
    }

    /**
     * @return Success
     */
    sitesGetById(id: number): Promise<SiteResponse> {
        let url_ = this.baseUrl + "/sites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSitesGetById(_response);
        });
    }

    protected processSitesGetById(response: Response): Promise<SiteResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SiteResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SiteResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitesUpdate(id: number, body?: SiteRequest | undefined): Promise<SiteResponse> {
        let url_ = this.baseUrl + "/sites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSitesUpdate(_response);
        });
    }

    protected processSitesUpdate(response: Response): Promise<SiteResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SiteResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SiteResponse>(null as any);
    }

    /**
     * @return Success
     */
    sitesDelete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/sites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSitesDelete(_response);
        });
    }

    protected processSitesDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    tagsCreate(siteId?: number | undefined, body?: TagRequest | undefined): Promise<TagResponse> {
        let url_ = this.baseUrl + "/tags?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTagsCreate(_response);
        });
    }

    protected processTagsCreate(response: Response): Promise<TagResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return Success
     */
    tagsList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined): Promise<TagResponsePaginatedList> {
        let url_ = this.baseUrl + "/tags?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTagsList(_response);
        });
    }

    protected processTagsList(response: Response): Promise<TagResponsePaginatedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagResponsePaginatedList.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagResponsePaginatedList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    tagsGetById(id: number, siteId?: number | undefined): Promise<TagResponse> {
        let url_ = this.baseUrl + "/tags/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTagsGetById(_response);
        });
    }

    protected processTagsGetById(response: Response): Promise<TagResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return Success
     */
    tagsUpdate(id: number, siteId?: number | undefined, body?: TagRequest | undefined): Promise<TagResponse> {
        let url_ = this.baseUrl + "/tags/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTagsUpdate(_response);
        });
    }

    protected processTagsUpdate(response: Response): Promise<TagResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagResponse>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return Success
     */
    tagsDelete(id: number, siteId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/tags/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTagsDelete(_response);
        });
    }

    protected processTagsDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    usersSession(): Promise<CurrentSession> {
        let url_ = this.baseUrl + "/users/session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUsersSession(_response);
        });
    }

    protected processUsersSession(response: Response): Promise<CurrentSession> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentSession.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrentSession>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersRegister(body?: RegisterRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUsersRegister(_response);
        });
    }

    protected processUsersRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersLogin(body?: AuthRequest | undefined): Promise<AuthResponse> {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUsersLogin(_response);
        });
    }

    protected processUsersLogin(response: Response): Promise<AuthResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthResponse>(null as any);
    }
}

export class AssetRequest implements IAssetRequest {
    file?: string | null;
    caption?: string | null;
    description?: string | null;
    accessRoles?: string | null;
    imageWidth?: string | null;
    imageHeight?: string | null;
    generateThumbnails?: boolean | null;
    folderId?: number | null;

    constructor(data?: IAssetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"] !== undefined ? _data["file"] : <any>null;
            this.caption = _data["caption"] !== undefined ? _data["caption"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.accessRoles = _data["accessRoles"] !== undefined ? _data["accessRoles"] : <any>null;
            this.imageWidth = _data["imageWidth"] !== undefined ? _data["imageWidth"] : <any>null;
            this.imageHeight = _data["imageHeight"] !== undefined ? _data["imageHeight"] : <any>null;
            this.generateThumbnails = _data["generateThumbnails"] !== undefined ? _data["generateThumbnails"] : <any>null;
            this.folderId = _data["folderId"] !== undefined ? _data["folderId"] : <any>null;
        }
    }

    static fromJS(data: any): AssetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["caption"] = this.caption !== undefined ? this.caption : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["accessRoles"] = this.accessRoles !== undefined ? this.accessRoles : <any>null;
        data["imageWidth"] = this.imageWidth !== undefined ? this.imageWidth : <any>null;
        data["imageHeight"] = this.imageHeight !== undefined ? this.imageHeight : <any>null;
        data["generateThumbnails"] = this.generateThumbnails !== undefined ? this.generateThumbnails : <any>null;
        data["folderId"] = this.folderId !== undefined ? this.folderId : <any>null;
        return data;
    }
}

export interface IAssetRequest {
    file?: string | null;
    caption?: string | null;
    description?: string | null;
    accessRoles?: string | null;
    imageWidth?: string | null;
    imageHeight?: string | null;
    generateThumbnails?: boolean | null;
    folderId?: number | null;
}

export class AssetResponse implements IAssetResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    filename?: string | null;
    assetPath?: string | null;
    caption?: string | null;
    description?: string | null;
    type?: string | null;
    accessRoles?: string | null;
    imageWidth?: string | null;
    imageHeight?: string | null;
    generateThumbnails?: boolean | null;

    constructor(data?: IAssetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? SiteResponse.fromJS(_data["site"]) : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.filename = _data["filename"] !== undefined ? _data["filename"] : <any>null;
            this.assetPath = _data["assetPath"] !== undefined ? _data["assetPath"] : <any>null;
            this.caption = _data["caption"] !== undefined ? _data["caption"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.accessRoles = _data["accessRoles"] !== undefined ? _data["accessRoles"] : <any>null;
            this.imageWidth = _data["imageWidth"] !== undefined ? _data["imageWidth"] : <any>null;
            this.imageHeight = _data["imageHeight"] !== undefined ? _data["imageHeight"] : <any>null;
            this.generateThumbnails = _data["generateThumbnails"] !== undefined ? _data["generateThumbnails"] : <any>null;
        }
    }

    static fromJS(data: any): AssetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AssetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["filename"] = this.filename !== undefined ? this.filename : <any>null;
        data["assetPath"] = this.assetPath !== undefined ? this.assetPath : <any>null;
        data["caption"] = this.caption !== undefined ? this.caption : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["accessRoles"] = this.accessRoles !== undefined ? this.accessRoles : <any>null;
        data["imageWidth"] = this.imageWidth !== undefined ? this.imageWidth : <any>null;
        data["imageHeight"] = this.imageHeight !== undefined ? this.imageHeight : <any>null;
        data["generateThumbnails"] = this.generateThumbnails !== undefined ? this.generateThumbnails : <any>null;
        return data;
    }
}

export interface IAssetResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    filename?: string | null;
    assetPath?: string | null;
    caption?: string | null;
    description?: string | null;
    type?: string | null;
    accessRoles?: string | null;
    imageWidth?: string | null;
    imageHeight?: string | null;
    generateThumbnails?: boolean | null;
}

export class AssetResponsePaginatedList implements IAssetResponsePaginatedList {
    items?: AssetResponse[] | null;
    pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IAssetResponsePaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AssetResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): AssetResponsePaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new AssetResponsePaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IAssetResponsePaginatedList {
    items?: AssetResponse[] | null;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AuthRequest implements IAuthRequest {
    email?: string | null;
    password?: string | null;

    constructor(data?: IAuthRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): AuthRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IAuthRequest {
    email?: string | null;
    password?: string | null;
}

export class AuthResponse implements IAuthResponse {
    username?: string | null;
    email?: string | null;
    token?: string | null;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any): AuthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data;
    }
}

export interface IAuthResponse {
    username?: string | null;
    email?: string | null;
    token?: string | null;
}

export class Category implements ICategory {
    id?: number;
    siteId?: number;
    site?: Site;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    readonly slug?: string | null;
    description?: string | null;
    banner?: string | null;
    icon?: string | null;
    readonly posts?: Post[] | null;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? Site.fromJS(_data["site"]) : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            (<any>this).slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            if (Array.isArray(_data["posts"])) {
                (<any>this).posts = [] as any;
                for (let item of _data["posts"])
                    (<any>this).posts!.push(Post.fromJS(item));
            }
            else {
                (<any>this).posts = <any>null;
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        if (Array.isArray(this.posts)) {
            data["posts"] = [];
            for (let item of this.posts)
                data["posts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategory {
    id?: number;
    siteId?: number;
    site?: Site;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    slug?: string | null;
    description?: string | null;
    banner?: string | null;
    icon?: string | null;
    posts?: Post[] | null;
}

export class CategoryRequest implements ICategoryRequest {
    name?: string | null;
    description?: string | null;
    slug?: string | null;
    banner?: string | null;
    icon?: string | null;

    constructor(data?: ICategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        return data;
    }
}

export interface ICategoryRequest {
    name?: string | null;
    description?: string | null;
    slug?: string | null;
    banner?: string | null;
    icon?: string | null;
}

export class CategoryResponse implements ICategoryResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    description?: string | null;
    slug?: string | null;
    banner?: string | null;
    icon?: string | null;
    readonly posts?: Post[] | null;

    constructor(data?: ICategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? SiteResponse.fromJS(_data["site"]) : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            if (Array.isArray(_data["posts"])) {
                (<any>this).posts = [] as any;
                for (let item of _data["posts"])
                    (<any>this).posts!.push(Post.fromJS(item));
            }
            else {
                (<any>this).posts = <any>null;
            }
        }
    }

    static fromJS(data: any): CategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        if (Array.isArray(this.posts)) {
            data["posts"] = [];
            for (let item of this.posts)
                data["posts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    description?: string | null;
    slug?: string | null;
    banner?: string | null;
    icon?: string | null;
    posts?: Post[] | null;
}

export class CategoryResponsePaginatedList implements ICategoryResponsePaginatedList {
    items?: CategoryResponse[] | null;
    pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: ICategoryResponsePaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryResponsePaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryResponsePaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ICategoryResponsePaginatedList {
    items?: CategoryResponse[] | null;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CurrentSession implements ICurrentSession {
    username?: string | null;

    constructor(data?: ICurrentSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
        }
    }

    static fromJS(data: any): CurrentSession {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        return data;
    }
}

export interface ICurrentSession {
    username?: string | null;
}

export class FolderResponse implements IFolderResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    accessRoles?: string | null;
    parentFolderId?: number | null;
    parentFolder?: FolderResponse;
    subFolders?: FolderResponse[] | null;

    constructor(data?: IFolderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? SiteResponse.fromJS(_data["site"]) : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.accessRoles = _data["accessRoles"] !== undefined ? _data["accessRoles"] : <any>null;
            this.parentFolderId = _data["parentFolderId"] !== undefined ? _data["parentFolderId"] : <any>null;
            this.parentFolder = _data["parentFolder"] ? FolderResponse.fromJS(_data["parentFolder"]) : <any>null;
            if (Array.isArray(_data["subFolders"])) {
                this.subFolders = [] as any;
                for (let item of _data["subFolders"])
                    this.subFolders!.push(FolderResponse.fromJS(item));
            }
            else {
                this.subFolders = <any>null;
            }
        }
    }

    static fromJS(data: any): FolderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FolderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["accessRoles"] = this.accessRoles !== undefined ? this.accessRoles : <any>null;
        data["parentFolderId"] = this.parentFolderId !== undefined ? this.parentFolderId : <any>null;
        data["parentFolder"] = this.parentFolder ? this.parentFolder.toJSON() : <any>null;
        if (Array.isArray(this.subFolders)) {
            data["subFolders"] = [];
            for (let item of this.subFolders)
                data["subFolders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFolderResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    accessRoles?: string | null;
    parentFolderId?: number | null;
    parentFolder?: FolderResponse;
    subFolders?: FolderResponse[] | null;
}

export class MessageRequest implements IMessageRequest {
    name?: string | null;
    email?: string | null;
    body?: string | null;

    constructor(data?: IMessageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): MessageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MessageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface IMessageRequest {
    name?: string | null;
    email?: string | null;
    body?: string | null;
}

export class MessageResponse implements IMessageResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    name?: string | null;
    email?: string | null;
    body?: string | null;
    created?: Date;

    constructor(data?: IMessageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? SiteResponse.fromJS(_data["site"]) : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): MessageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MessageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        return data;
    }
}

export interface IMessageResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    name?: string | null;
    email?: string | null;
    body?: string | null;
    created?: Date;
}

export class MessageResponsePaginatedList implements IMessageResponsePaginatedList {
    items?: MessageResponse[] | null;
    pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IMessageResponsePaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MessageResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): MessageResponsePaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new MessageResponsePaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IMessageResponsePaginatedList {
    items?: MessageResponse[] | null;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class Post implements IPost {
    id?: number;
    siteId?: number;
    site?: Site;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    title?: string | null;
    readonly slug?: string | null;
    description?: string | null;
    author?: string | null;
    authorAvatar?: string | null;
    image?: string | null;
    ogImage?: string | null;
    ogTitle?: string | null;
    ogType?: string | null;
    body?: string | null;
    publishDate?: Date;
    readonly tags?: Tag[] | null;
    categoryId?: number;
    category?: Category;

    constructor(data?: IPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? Site.fromJS(_data["site"]) : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            (<any>this).slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.author = _data["author"] !== undefined ? _data["author"] : <any>null;
            this.authorAvatar = _data["authorAvatar"] !== undefined ? _data["authorAvatar"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.ogImage = _data["ogImage"] !== undefined ? _data["ogImage"] : <any>null;
            this.ogTitle = _data["ogTitle"] !== undefined ? _data["ogTitle"] : <any>null;
            this.ogType = _data["ogType"] !== undefined ? _data["ogType"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
            this.publishDate = _data["publishDate"] ? new Date(_data["publishDate"].toString()) : <any>null;
            if (Array.isArray(_data["tags"])) {
                (<any>this).tags = [] as any;
                for (let item of _data["tags"])
                    (<any>this).tags!.push(Tag.fromJS(item));
            }
            else {
                (<any>this).tags = <any>null;
            }
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>null;
        }
    }

    static fromJS(data: any): Post {
        data = typeof data === 'object' ? data : {};
        let result = new Post();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        data["authorAvatar"] = this.authorAvatar !== undefined ? this.authorAvatar : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["ogImage"] = this.ogImage !== undefined ? this.ogImage : <any>null;
        data["ogTitle"] = this.ogTitle !== undefined ? this.ogTitle : <any>null;
        data["ogType"] = this.ogType !== undefined ? this.ogType : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        return data;
    }
}

export interface IPost {
    id?: number;
    siteId?: number;
    site?: Site;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    title?: string | null;
    slug?: string | null;
    description?: string | null;
    author?: string | null;
    authorAvatar?: string | null;
    image?: string | null;
    ogImage?: string | null;
    ogTitle?: string | null;
    ogType?: string | null;
    body?: string | null;
    publishDate?: Date;
    tags?: Tag[] | null;
    categoryId?: number;
    category?: Category;
}

export class PostRequest implements IPostRequest {
    title?: string | null;
    description?: string | null;
    author?: string | null;
    authorAvatar?: string | null;
    image?: string | null;
    ogImage?: string | null;
    ogTitle?: string | null;
    ogType?: string | null;
    body?: string | null;
    publishDate?: Date | null;
    categoryId?: number;
    tags?: string | null;

    constructor(data?: IPostRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.author = _data["author"] !== undefined ? _data["author"] : <any>null;
            this.authorAvatar = _data["authorAvatar"] !== undefined ? _data["authorAvatar"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.ogImage = _data["ogImage"] !== undefined ? _data["ogImage"] : <any>null;
            this.ogTitle = _data["ogTitle"] !== undefined ? _data["ogTitle"] : <any>null;
            this.ogType = _data["ogType"] !== undefined ? _data["ogType"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
            this.publishDate = _data["publishDate"] ? new Date(_data["publishDate"].toString()) : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.tags = _data["tags"] !== undefined ? _data["tags"] : <any>null;
        }
    }

    static fromJS(data: any): PostRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PostRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        data["authorAvatar"] = this.authorAvatar !== undefined ? this.authorAvatar : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["ogImage"] = this.ogImage !== undefined ? this.ogImage : <any>null;
        data["ogTitle"] = this.ogTitle !== undefined ? this.ogTitle : <any>null;
        data["ogType"] = this.ogType !== undefined ? this.ogType : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["tags"] = this.tags !== undefined ? this.tags : <any>null;
        return data;
    }
}

export interface IPostRequest {
    title?: string | null;
    description?: string | null;
    author?: string | null;
    authorAvatar?: string | null;
    image?: string | null;
    ogImage?: string | null;
    ogTitle?: string | null;
    ogType?: string | null;
    body?: string | null;
    publishDate?: Date | null;
    categoryId?: number;
    tags?: string | null;
}

export class PostResponse implements IPostResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    title?: string | null;
    description?: string | null;
    author?: string | null;
    authorAvatar?: string | null;
    image?: string | null;
    ogImage?: string | null;
    ogTitle?: string | null;
    ogType?: string | null;
    body?: string | null;
    publishDate?: Date;
    readonly tags?: string | null;
    category?: Category;

    constructor(data?: IPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? SiteResponse.fromJS(_data["site"]) : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.author = _data["author"] !== undefined ? _data["author"] : <any>null;
            this.authorAvatar = _data["authorAvatar"] !== undefined ? _data["authorAvatar"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.ogImage = _data["ogImage"] !== undefined ? _data["ogImage"] : <any>null;
            this.ogTitle = _data["ogTitle"] !== undefined ? _data["ogTitle"] : <any>null;
            this.ogType = _data["ogType"] !== undefined ? _data["ogType"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
            this.publishDate = _data["publishDate"] ? new Date(_data["publishDate"].toString()) : <any>null;
            (<any>this).tags = _data["tags"] !== undefined ? _data["tags"] : <any>null;
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>null;
        }
    }

    static fromJS(data: any): PostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        data["authorAvatar"] = this.authorAvatar !== undefined ? this.authorAvatar : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["ogImage"] = this.ogImage !== undefined ? this.ogImage : <any>null;
        data["ogTitle"] = this.ogTitle !== undefined ? this.ogTitle : <any>null;
        data["ogType"] = this.ogType !== undefined ? this.ogType : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>null;
        data["tags"] = this.tags !== undefined ? this.tags : <any>null;
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        return data;
    }
}

export interface IPostResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    title?: string | null;
    description?: string | null;
    author?: string | null;
    authorAvatar?: string | null;
    image?: string | null;
    ogImage?: string | null;
    ogTitle?: string | null;
    ogType?: string | null;
    body?: string | null;
    publishDate?: Date;
    tags?: string | null;
    category?: Category;
}

export class PostResponsePaginatedList implements IPostResponsePaginatedList {
    items?: PostResponse[] | null;
    pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IPostResponsePaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PostResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PostResponsePaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new PostResponsePaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IPostResponsePaginatedList {
    items?: PostResponse[] | null;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProjectRequest implements IProjectRequest {
    name?: string | null;
    description?: string | null;
    github?: string | null;
    demo?: string | null;
    image?: string | null;
    body?: string | null;

    constructor(data?: IProjectRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.github = _data["github"] !== undefined ? _data["github"] : <any>null;
            this.demo = _data["demo"] !== undefined ? _data["demo"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): ProjectRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["github"] = this.github !== undefined ? this.github : <any>null;
        data["demo"] = this.demo !== undefined ? this.demo : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface IProjectRequest {
    name?: string | null;
    description?: string | null;
    github?: string | null;
    demo?: string | null;
    image?: string | null;
    body?: string | null;
}

export class ProjectResponse implements IProjectResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    description?: string | null;
    slug?: string | null;
    github?: string | null;
    demo?: string | null;
    image?: string | null;
    body?: string | null;

    constructor(data?: IProjectResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? SiteResponse.fromJS(_data["site"]) : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.github = _data["github"] !== undefined ? _data["github"] : <any>null;
            this.demo = _data["demo"] !== undefined ? _data["demo"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): ProjectResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["github"] = this.github !== undefined ? this.github : <any>null;
        data["demo"] = this.demo !== undefined ? this.demo : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface IProjectResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    description?: string | null;
    slug?: string | null;
    github?: string | null;
    demo?: string | null;
    image?: string | null;
    body?: string | null;
}

export class ProjectResponsePaginatedList implements IProjectResponsePaginatedList {
    items?: ProjectResponse[] | null;
    pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IProjectResponsePaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProjectResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ProjectResponsePaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectResponsePaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IProjectResponsePaginatedList {
    items?: ProjectResponse[] | null;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string;
    username!: string;
    password!: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IRegisterRequest {
    email: string;
    username: string;
    password: string;
}

export class Site implements ISite {
    id?: number;
    name?: string | null;
    readonly slug?: string | null;
    description?: string | null;
    baseUrl?: string | null;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;

    constructor(data?: ISite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            (<any>this).slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.baseUrl = _data["baseUrl"] !== undefined ? _data["baseUrl"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
        }
    }

    static fromJS(data: any): Site {
        data = typeof data === 'object' ? data : {};
        let result = new Site();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["baseUrl"] = this.baseUrl !== undefined ? this.baseUrl : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        return data;
    }
}

export interface ISite {
    id?: number;
    name?: string | null;
    slug?: string | null;
    description?: string | null;
    baseUrl?: string | null;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
}

export class SiteRequest implements ISiteRequest {
    name?: string | null;
    description?: string | null;
    baseUrl?: string | null;

    constructor(data?: ISiteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.baseUrl = _data["baseUrl"] !== undefined ? _data["baseUrl"] : <any>null;
        }
    }

    static fromJS(data: any): SiteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SiteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["baseUrl"] = this.baseUrl !== undefined ? this.baseUrl : <any>null;
        return data;
    }
}

export interface ISiteRequest {
    name?: string | null;
    description?: string | null;
    baseUrl?: string | null;
}

export class SiteResponse implements ISiteResponse {
    id?: number;
    name?: string | null;
    slug?: string | null;
    description?: string | null;
    baseUrl?: string | null;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;

    constructor(data?: ISiteResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.baseUrl = _data["baseUrl"] !== undefined ? _data["baseUrl"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
        }
    }

    static fromJS(data: any): SiteResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SiteResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["baseUrl"] = this.baseUrl !== undefined ? this.baseUrl : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        return data;
    }
}

export interface ISiteResponse {
    id?: number;
    name?: string | null;
    slug?: string | null;
    description?: string | null;
    baseUrl?: string | null;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
}

export class SiteResponsePaginatedList implements ISiteResponsePaginatedList {
    items?: SiteResponse[] | null;
    pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: ISiteResponsePaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SiteResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): SiteResponsePaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new SiteResponsePaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ISiteResponsePaginatedList {
    items?: SiteResponse[] | null;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class Tag implements ITag {
    id?: number;
    siteId?: number;
    site?: Site;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    readonly slug?: string | null;
    description?: string | null;
    icon?: string | null;
    banner?: string | null;
    readonly posts?: Post[] | null;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? Site.fromJS(_data["site"]) : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            (<any>this).slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
            if (Array.isArray(_data["posts"])) {
                (<any>this).posts = [] as any;
                for (let item of _data["posts"])
                    (<any>this).posts!.push(Post.fromJS(item));
            }
            else {
                (<any>this).posts = <any>null;
            }
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        if (Array.isArray(this.posts)) {
            data["posts"] = [];
            for (let item of this.posts)
                data["posts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITag {
    id?: number;
    siteId?: number;
    site?: Site;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    slug?: string | null;
    description?: string | null;
    icon?: string | null;
    banner?: string | null;
    posts?: Post[] | null;
}

export class TagRequest implements ITagRequest {
    name?: string | null;
    description?: string | null;
    icon?: string | null;
    banner?: string | null;

    constructor(data?: ITagRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
        }
    }

    static fromJS(data: any): TagRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TagRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        return data;
    }
}

export interface ITagRequest {
    name?: string | null;
    description?: string | null;
    icon?: string | null;
    banner?: string | null;
}

export class TagResponse implements ITagResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    description?: string | null;
    icon?: string | null;
    banner?: string | null;
    readonly posts?: Post[] | null;

    constructor(data?: ITagResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.site = _data["site"] ? SiteResponse.fromJS(_data["site"]) : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
            if (Array.isArray(_data["posts"])) {
                (<any>this).posts = [] as any;
                for (let item of _data["posts"])
                    (<any>this).posts!.push(Post.fromJS(item));
            }
            else {
                (<any>this).posts = <any>null;
            }
        }
    }

    static fromJS(data: any): TagResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TagResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        if (Array.isArray(this.posts)) {
            data["posts"] = [];
            for (let item of this.posts)
                data["posts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITagResponse {
    id?: number;
    siteId?: number;
    site?: SiteResponse;
    created?: Date;
    createdBy?: string | null;
    lastModified?: Date;
    lastModifiedBy?: string | null;
    name?: string | null;
    description?: string | null;
    icon?: string | null;
    banner?: string | null;
    posts?: Post[] | null;
}

export class TagResponsePaginatedList implements ITagResponsePaginatedList {
    items?: TagResponse[] | null;
    pageNumber?: number;
    readonly totalPages?: number;
    readonly totalCount?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: ITagResponsePaginatedList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagResponse.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): TagResponsePaginatedList {
        data = typeof data === 'object' ? data : {};
        let result = new TagResponsePaginatedList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ITagResponsePaginatedList {
    items?: TagResponse[] | null;
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/**
 * Configuration class needed in base class.
 * The config is provided to the API client at initialization time.
 * API clients inherit from #AuthorizedApiBase and provide the config.
 */
export class ApiConfig {
    /**
     * Returns a valid value for the Authorization header.
     * Used to dynamically inject the current auth header.
     */
    getAuthorization() {
        return "Bearer " + localStorage.getItem('AdminAuthToken') || "";
    }
}

export function setAuthorizationToken(token: string | null) {
    if (token == null) {
        localStorage.removeItem('AdminAuthToken');
    } else {
        localStorage.setItem('AdminAuthToken', token);
    }
}