//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosHeaders, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';
export class AuthorizedApiBase {
    private readonly config: ApiConfig;

    protected constructor(config: ApiConfig) {
        this.config = config;
    }

    protected transformOptions = (options: AxiosRequestConfig): Promise<AxiosRequestConfig> => {
        options.headers = {
            ...options.headers,
        };
        if (!this.config.isAnonymous()) {

            if (options.headers.common == undefined) options.headers.common = new AxiosHeaders();

            if (this.config.isApiKeyAuth()) {
                options.headers.common['X-Api-Key'] = this.config.getApiKey();
            } else {
                options.headers.common['Authorization'] = this.config.getAuthorization();
            }
        }
        return Promise.resolve(options);
    };

    protected transformResult(url: string, response: AxiosResponse, processor: (response: AxiosResponse) => any) {
        
        var authResponse = response.headers['www-authenticate'] || "";

        if (authResponse.indexOf('token expired') >= 0) {
            // user's token has expired
            // need to redirect to the login page
            this.config.loggedOutCallback();
        }

        return processor(response); 
    }
}

export class Client extends AuthorizedApiBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: ApiConfig, baseUrl?: string, instance?: AxiosInstance) {

        super(configuration);

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param siteId (optional) 
     * @param file (optional) 
     * @param caption (optional) 
     * @param description (optional) 
     * @param accessRoles (optional) 
     * @param imageWidth (optional) 
     * @param imageHeight (optional) 
     * @param generateThumbnails (optional) 
     * @param folderId (optional) 
     * @return OK
     */
    assetsUpload(siteId?: number | undefined, file?: FileParameter | undefined, caption?: string | undefined, description?: string | undefined, accessRoles?: string | undefined, imageWidth?: number | undefined, imageHeight?: number | undefined, generateThumbnails?: boolean | undefined, folderId?: number | undefined, cancelToken?: CancelToken): Promise<Asset> {
        let url_ = this.baseUrl + "/assets?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (caption === null || caption === undefined)
            throw new Error("The parameter 'caption' cannot be null.");
        else
            content_.append("caption", caption.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("description", description.toString());
        if (accessRoles === null || accessRoles === undefined)
            throw new Error("The parameter 'accessRoles' cannot be null.");
        else
            content_.append("accessRoles", accessRoles.toString());
        if (imageWidth === null || imageWidth === undefined)
            throw new Error("The parameter 'imageWidth' cannot be null.");
        else
            content_.append("imageWidth", imageWidth.toString());
        if (imageHeight === null || imageHeight === undefined)
            throw new Error("The parameter 'imageHeight' cannot be null.");
        else
            content_.append("imageHeight", imageHeight.toString());
        if (generateThumbnails === null || generateThumbnails === undefined)
            throw new Error("The parameter 'generateThumbnails' cannot be null.");
        else
            content_.append("generateThumbnails", generateThumbnails.toString());
        if (folderId === null || folderId === undefined)
            throw new Error("The parameter 'folderId' cannot be null.");
        else
            content_.append("folderId", folderId.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAssetsUpload(_response));
        });
    }

    protected processAssetsUpload(response: AxiosResponse): Promise<Asset> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Asset.fromJS(resultData200);
            return Promise.resolve<Asset>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Asset>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    assetsGetAllFolders(siteId?: number | undefined, cancelToken?: CancelToken): Promise<Folder[]> {
        let url_ = this.baseUrl + "/assets?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAssetsGetAllFolders(_response));
        });
    }

    protected processAssetsGetAllFolders(response: AxiosResponse): Promise<Folder[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Folder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Folder[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Folder[]>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @param siteId (optional) 
     * @return OK
     */
    assetsList(pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, siteId?: number | undefined, cancelToken?: CancelToken): Promise<AssetList> {
        let url_ = this.baseUrl + "/assets/all?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAssetsList(_response));
        });
    }

    protected processAssetsList(response: AxiosResponse): Promise<AssetList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssetList.fromJS(resultData200);
            return Promise.resolve<AssetList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssetList>(null as any);
    }

    /**
     * @param folderId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @param siteId (optional) 
     * @return OK
     */
    assetsGetByFolder(folderId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, siteId?: number | undefined, cancelToken?: CancelToken): Promise<AssetList> {
        let url_ = this.baseUrl + "/assets/folder?";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAssetsGetByFolder(_response));
        });
    }

    protected processAssetsGetByFolder(response: AxiosResponse): Promise<AssetList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssetList.fromJS(resultData200);
            return Promise.resolve<AssetList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssetList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    assetsCreateFolder(siteId?: number | undefined, body?: FolderRequest | undefined, cancelToken?: CancelToken): Promise<Folder> {
        let url_ = this.baseUrl + "/assets/folder?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAssetsCreateFolder(_response));
        });
    }

    protected processAssetsCreateFolder(response: AxiosResponse): Promise<Folder> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Folder.fromJS(resultData200);
            return Promise.resolve<Folder>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Folder>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    assetsGetById(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<Asset> {
        let url_ = this.baseUrl + "/assets/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAssetsGetById(_response));
        });
    }

    protected processAssetsGetById(response: AxiosResponse): Promise<Asset> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Asset.fromJS(resultData200);
            return Promise.resolve<Asset>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Asset>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    assetsUpdate(id: number, siteId?: number | undefined, body?: AssetRequest | undefined, cancelToken?: CancelToken): Promise<Asset> {
        let url_ = this.baseUrl + "/assets/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAssetsUpdate(_response));
        });
    }

    protected processAssetsUpdate(response: AxiosResponse): Promise<Asset> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Asset.fromJS(resultData200);
            return Promise.resolve<Asset>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Asset>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    assetsDelete(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/assets/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAssetsDelete(_response));
        });
    }

    protected processAssetsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    categoriesCreate(siteId?: number | undefined, body?: CategoryRequest | undefined, cancelToken?: CancelToken): Promise<Category> {
        let url_ = this.baseUrl + "/categories?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCategoriesCreate(_response));
        });
    }

    protected processCategoriesCreate(response: AxiosResponse): Promise<Category> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Category.fromJS(resultData200);
            return Promise.resolve<Category>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return OK
     */
    categoriesList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, cancelToken?: CancelToken): Promise<CategoryList> {
        let url_ = this.baseUrl + "/categories?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCategoriesList(_response));
        });
    }

    protected processCategoriesList(response: AxiosResponse): Promise<CategoryList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryList.fromJS(resultData200);
            return Promise.resolve<CategoryList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    categoriesGetById(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<Category> {
        let url_ = this.baseUrl + "/categories/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCategoriesGetById(_response));
        });
    }

    protected processCategoriesGetById(response: AxiosResponse): Promise<Category> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Category.fromJS(resultData200);
            return Promise.resolve<Category>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    categoriesUpdate(id: number, siteId?: number | undefined, body?: CategoryRequest | undefined, cancelToken?: CancelToken): Promise<Category> {
        let url_ = this.baseUrl + "/categories/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCategoriesUpdate(_response));
        });
    }

    protected processCategoriesUpdate(response: AxiosResponse): Promise<Category> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Category.fromJS(resultData200);
            return Promise.resolve<Category>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    categoriesDelete(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/categories/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCategoriesDelete(_response));
        });
    }

    protected processCategoriesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    messagesSend(siteId?: number | undefined, body?: MessageRequest | undefined, cancelToken?: CancelToken): Promise<Message> {
        let url_ = this.baseUrl + "/messages/send?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMessagesSend(_response));
        });
    }

    protected processMessagesSend(response: AxiosResponse): Promise<Message> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Message.fromJS(resultData200);
            return Promise.resolve<Message>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Message>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return OK
     */
    messagesList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, cancelToken?: CancelToken): Promise<MessageList> {
        let url_ = this.baseUrl + "/messages?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMessagesList(_response));
        });
    }

    protected processMessagesList(response: AxiosResponse): Promise<MessageList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MessageList.fromJS(resultData200);
            return Promise.resolve<MessageList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MessageList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    messagesDelete(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/messages/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMessagesDelete(_response));
        });
    }

    protected processMessagesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    postsCreate(siteId?: number | undefined, body?: PostRequest | undefined, cancelToken?: CancelToken): Promise<Post> {
        let url_ = this.baseUrl + "/posts?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostsCreate(_response));
        });
    }

    protected processPostsCreate(response: AxiosResponse): Promise<Post> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Post.fromJS(resultData200);
            return Promise.resolve<Post>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Post>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return OK
     */
    postsList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, cancelToken?: CancelToken): Promise<PostList> {
        let url_ = this.baseUrl + "/posts?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostsList(_response));
        });
    }

    protected processPostsList(response: AxiosResponse): Promise<PostList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostList.fromJS(resultData200);
            return Promise.resolve<PostList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    postsUpdate(id: number, siteId?: number | undefined, body?: PostRequest | undefined, cancelToken?: CancelToken): Promise<Post> {
        let url_ = this.baseUrl + "/posts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostsUpdate(_response));
        });
    }

    protected processPostsUpdate(response: AxiosResponse): Promise<Post> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Post.fromJS(resultData200);
            return Promise.resolve<Post>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Post>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    postsDelete(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/posts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostsDelete(_response));
        });
    }

    protected processPostsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    postsGetById(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<Post> {
        let url_ = this.baseUrl + "/posts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostsGetById(_response));
        });
    }

    protected processPostsGetById(response: AxiosResponse): Promise<Post> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Post.fromJS(resultData200);
            return Promise.resolve<Post>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Post>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return OK
     */
    postsFeatured(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, cancelToken?: CancelToken): Promise<PostList> {
        let url_ = this.baseUrl + "/posts/featured?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostsFeatured(_response));
        });
    }

    protected processPostsFeatured(response: AxiosResponse): Promise<PostList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostList.fromJS(resultData200);
            return Promise.resolve<PostList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return OK
     */
    postsGetByTag(tagSlug: string, siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, cancelToken?: CancelToken): Promise<PostList> {
        let url_ = this.baseUrl + "/posts/tag/{tagSlug}?";
        if (tagSlug === undefined || tagSlug === null)
            throw new Error("The parameter 'tagSlug' must be defined.");
        url_ = url_.replace("{tagSlug}", encodeURIComponent("" + tagSlug));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostsGetByTag(_response));
        });
    }

    protected processPostsGetByTag(response: AxiosResponse): Promise<PostList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostList.fromJS(resultData200);
            return Promise.resolve<PostList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return OK
     */
    postsGetByCategory(categorySlug: string, siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, cancelToken?: CancelToken): Promise<PostList> {
        let url_ = this.baseUrl + "/posts/category/{categorySlug}?";
        if (categorySlug === undefined || categorySlug === null)
            throw new Error("The parameter 'categorySlug' must be defined.");
        url_ = url_.replace("{categorySlug}", encodeURIComponent("" + categorySlug));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostsGetByCategory(_response));
        });
    }

    protected processPostsGetByCategory(response: AxiosResponse): Promise<PostList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostList.fromJS(resultData200);
            return Promise.resolve<PostList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    postsGetBySlug(categorySlug: string, postSlug: string, siteId?: number | undefined, cancelToken?: CancelToken): Promise<Post> {
        let url_ = this.baseUrl + "/posts/category/{categorySlug}/{postSlug}?";
        if (categorySlug === undefined || categorySlug === null)
            throw new Error("The parameter 'categorySlug' must be defined.");
        url_ = url_.replace("{categorySlug}", encodeURIComponent("" + categorySlug));
        if (postSlug === undefined || postSlug === null)
            throw new Error("The parameter 'postSlug' must be defined.");
        url_ = url_.replace("{postSlug}", encodeURIComponent("" + postSlug));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostsGetBySlug(_response));
        });
    }

    protected processPostsGetBySlug(response: AxiosResponse): Promise<Post> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Post.fromJS(resultData200);
            return Promise.resolve<Post>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Post>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    projectsCreate(siteId?: number | undefined, body?: ProjectRequest | undefined, cancelToken?: CancelToken): Promise<Project> {
        let url_ = this.baseUrl + "/projects?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectsCreate(_response));
        });
    }

    protected processProjectsCreate(response: AxiosResponse): Promise<Project> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Project.fromJS(resultData200);
            return Promise.resolve<Project>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Project>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return OK
     */
    projectsList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, cancelToken?: CancelToken): Promise<ProjectList> {
        let url_ = this.baseUrl + "/projects?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectsList(_response));
        });
    }

    protected processProjectsList(response: AxiosResponse): Promise<ProjectList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectList.fromJS(resultData200);
            return Promise.resolve<ProjectList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    projectsGetById(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<Project> {
        let url_ = this.baseUrl + "/projects/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectsGetById(_response));
        });
    }

    protected processProjectsGetById(response: AxiosResponse): Promise<Project> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Project.fromJS(resultData200);
            return Promise.resolve<Project>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Project>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    projectsUpdate(id: number, siteId?: number | undefined, body?: ProjectRequest | undefined, cancelToken?: CancelToken): Promise<Project> {
        let url_ = this.baseUrl + "/projects/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectsUpdate(_response));
        });
    }

    protected processProjectsUpdate(response: AxiosResponse): Promise<Project> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Project.fromJS(resultData200);
            return Promise.resolve<Project>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Project>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    projectsDelete(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/projects/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProjectsDelete(_response));
        });
    }

    protected processProjectsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sitesCreate(body?: SiteRequest | undefined, cancelToken?: CancelToken): Promise<Site> {
        let url_ = this.baseUrl + "/sites";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSitesCreate(_response));
        });
    }

    protected processSitesCreate(response: AxiosResponse): Promise<Site> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Site.fromJS(resultData200);
            return Promise.resolve<Site>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Site>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return OK
     */
    sitesList(pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, cancelToken?: CancelToken): Promise<SiteList> {
        let url_ = this.baseUrl + "/sites?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSitesList(_response));
        });
    }

    protected processSitesList(response: AxiosResponse): Promise<SiteList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SiteList.fromJS(resultData200);
            return Promise.resolve<SiteList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SiteList>(null as any);
    }

    /**
     * @return OK
     */
    sitesGetById(id: number, cancelToken?: CancelToken): Promise<Site> {
        let url_ = this.baseUrl + "/sites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSitesGetById(_response));
        });
    }

    protected processSitesGetById(response: AxiosResponse): Promise<Site> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Site.fromJS(resultData200);
            return Promise.resolve<Site>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Site>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sitesUpdate(id: number, body?: SiteRequest | undefined, cancelToken?: CancelToken): Promise<Site> {
        let url_ = this.baseUrl + "/sites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSitesUpdate(_response));
        });
    }

    protected processSitesUpdate(response: AxiosResponse): Promise<Site> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Site.fromJS(resultData200);
            return Promise.resolve<Site>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Site>(null as any);
    }

    /**
     * @return OK
     */
    sitesDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/sites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSitesDelete(_response));
        });
    }

    protected processSitesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    tagsCreate(siteId?: number | undefined, body?: TagRequest | undefined, cancelToken?: CancelToken): Promise<Tag> {
        let url_ = this.baseUrl + "/tags?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTagsCreate(_response));
        });
    }

    protected processTagsCreate(response: AxiosResponse): Promise<Tag> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Tag.fromJS(resultData200);
            return Promise.resolve<Tag>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Tag>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param orderBy (optional) 
     * @param orderDesc (optional) 
     * @return OK
     */
    tagsList(siteId?: number | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, orderBy?: string | undefined, orderDesc?: boolean | undefined, cancelToken?: CancelToken): Promise<TagList> {
        let url_ = this.baseUrl + "/tags?";
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderDesc === null)
            throw new Error("The parameter 'orderDesc' cannot be null.");
        else if (orderDesc !== undefined)
            url_ += "OrderDesc=" + encodeURIComponent("" + orderDesc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTagsList(_response));
        });
    }

    protected processTagsList(response: AxiosResponse): Promise<TagList> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TagList.fromJS(resultData200);
            return Promise.resolve<TagList>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagList>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    tagsGetById(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<Tag> {
        let url_ = this.baseUrl + "/tags/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTagsGetById(_response));
        });
    }

    protected processTagsGetById(response: AxiosResponse): Promise<Tag> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Tag.fromJS(resultData200);
            return Promise.resolve<Tag>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Tag>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @param body (optional) 
     * @return OK
     */
    tagsUpdate(id: number, siteId?: number | undefined, body?: TagRequest | undefined, cancelToken?: CancelToken): Promise<Tag> {
        let url_ = this.baseUrl + "/tags/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTagsUpdate(_response));
        });
    }

    protected processTagsUpdate(response: AxiosResponse): Promise<Tag> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Tag.fromJS(resultData200);
            return Promise.resolve<Tag>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Tag>(null as any);
    }

    /**
     * @param siteId (optional) 
     * @return OK
     */
    tagsDelete(id: number, siteId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/tags/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (siteId === null)
            throw new Error("The parameter 'siteId' cannot be null.");
        else if (siteId !== undefined)
            url_ += "siteId=" + encodeURIComponent("" + siteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTagsDelete(_response));
        });
    }

    protected processTagsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    usersSession( cancelToken?: CancelToken): Promise<CurrentSession> {
        let url_ = this.baseUrl + "/users/session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUsersSession(_response));
        });
    }

    protected processUsersSession(response: AxiosResponse): Promise<CurrentSession> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CurrentSession.fromJS(resultData200);
            return Promise.resolve<CurrentSession>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrentSession>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    usersRegister(body?: RegisterRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUsersRegister(_response));
        });
    }

    protected processUsersRegister(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    usersLogin(body?: AuthRequest | undefined, cancelToken?: CancelToken): Promise<Auth> {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUsersLogin(_response));
        });
    }

    protected processUsersLogin(response: AxiosResponse): Promise<Auth> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Auth.fromJS(resultData200);
            return Promise.resolve<Auth>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Auth>(null as any);
    }

    /**
     * @return OK
     */
    usersgenerateKey( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/users/generatekey";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUsersgenerateKey(_response));
        });
    }

    protected processUsersgenerateKey(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Asset implements IAsset {
    id!: number;
    siteId!: number;
    created!: Date;
    createdBy!: string | null;
    lastModified!: Date;
    lastModifiedBy!: string | null;
    filename!: string;
    assetPath!: string;
    caption!: string;
    description!: string;
    type!: string;
    accessRoles!: string | null;
    imageWidth!: string | null;
    imageHeight!: string | null;
    generateThumbnails!: boolean | null;
    folderId!: number | null;

    constructor(data?: IAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.filename = _data["filename"] !== undefined ? _data["filename"] : <any>null;
            this.assetPath = _data["assetPath"] !== undefined ? _data["assetPath"] : <any>null;
            this.caption = _data["caption"] !== undefined ? _data["caption"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.accessRoles = _data["accessRoles"] !== undefined ? _data["accessRoles"] : <any>null;
            this.imageWidth = _data["imageWidth"] !== undefined ? _data["imageWidth"] : <any>null;
            this.imageHeight = _data["imageHeight"] !== undefined ? _data["imageHeight"] : <any>null;
            this.generateThumbnails = _data["generateThumbnails"] !== undefined ? _data["generateThumbnails"] : <any>null;
            this.folderId = _data["folderId"] !== undefined ? _data["folderId"] : <any>null;
        }
    }

    static fromJS(data: any): Asset {
        data = typeof data === 'object' ? data : {};
        let result = new Asset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["filename"] = this.filename !== undefined ? this.filename : <any>null;
        data["assetPath"] = this.assetPath !== undefined ? this.assetPath : <any>null;
        data["caption"] = this.caption !== undefined ? this.caption : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["accessRoles"] = this.accessRoles !== undefined ? this.accessRoles : <any>null;
        data["imageWidth"] = this.imageWidth !== undefined ? this.imageWidth : <any>null;
        data["imageHeight"] = this.imageHeight !== undefined ? this.imageHeight : <any>null;
        data["generateThumbnails"] = this.generateThumbnails !== undefined ? this.generateThumbnails : <any>null;
        data["folderId"] = this.folderId !== undefined ? this.folderId : <any>null;
        return data;
    }
}

export interface IAsset {
    id: number;
    siteId: number;
    created: Date;
    createdBy: string | null;
    lastModified: Date;
    lastModifiedBy: string | null;
    filename: string;
    assetPath: string;
    caption: string;
    description: string;
    type: string;
    accessRoles: string | null;
    imageWidth: string | null;
    imageHeight: string | null;
    generateThumbnails: boolean | null;
    folderId: number | null;
}

export class AssetList implements IAssetList {
    items!: Asset[];
    pageNumber!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: IAssetList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Asset.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): AssetList {
        data = typeof data === 'object' ? data : {};
        let result = new AssetList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IAssetList {
    items: Asset[];
    pageNumber: number;
    totalPages: number;
    totalCount: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class AssetRequest implements IAssetRequest {
    caption!: string | null;
    description!: string | null;
    accessRoles!: string | null;
    imageWidth!: number | null;
    imageHeight!: number | null;
    generateThumbnails!: boolean | null;
    folderId!: number | null;

    constructor(data?: IAssetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caption = _data["caption"] !== undefined ? _data["caption"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.accessRoles = _data["accessRoles"] !== undefined ? _data["accessRoles"] : <any>null;
            this.imageWidth = _data["imageWidth"] !== undefined ? _data["imageWidth"] : <any>null;
            this.imageHeight = _data["imageHeight"] !== undefined ? _data["imageHeight"] : <any>null;
            this.generateThumbnails = _data["generateThumbnails"] !== undefined ? _data["generateThumbnails"] : <any>null;
            this.folderId = _data["folderId"] !== undefined ? _data["folderId"] : <any>null;
        }
    }

    static fromJS(data: any): AssetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caption"] = this.caption !== undefined ? this.caption : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["accessRoles"] = this.accessRoles !== undefined ? this.accessRoles : <any>null;
        data["imageWidth"] = this.imageWidth !== undefined ? this.imageWidth : <any>null;
        data["imageHeight"] = this.imageHeight !== undefined ? this.imageHeight : <any>null;
        data["generateThumbnails"] = this.generateThumbnails !== undefined ? this.generateThumbnails : <any>null;
        data["folderId"] = this.folderId !== undefined ? this.folderId : <any>null;
        return data;
    }
}

export interface IAssetRequest {
    caption: string | null;
    description: string | null;
    accessRoles: string | null;
    imageWidth: number | null;
    imageHeight: number | null;
    generateThumbnails: boolean | null;
    folderId: number | null;
}

export class Auth implements IAuth {
    username!: string | null;
    email!: string | null;
    token!: string | null;

    constructor(data?: IAuth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any): Auth {
        data = typeof data === 'object' ? data : {};
        let result = new Auth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data;
    }
}

export interface IAuth {
    username: string | null;
    email: string | null;
    token: string | null;
}

export class AuthRequest implements IAuthRequest {
    email!: string | null;
    password!: string | null;

    constructor(data?: IAuthRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): AuthRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IAuthRequest {
    email: string | null;
    password: string | null;
}

export class Category implements ICategory {
    id!: number;
    siteId!: number;
    created!: Date;
    createdBy!: string | null;
    lastModified!: Date;
    lastModifiedBy!: string | null;
    name!: string;
    description!: string;
    slug!: string;
    banner!: string | null;
    icon!: string | null;
    body!: string | null;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface ICategory {
    id: number;
    siteId: number;
    created: Date;
    createdBy: string | null;
    lastModified: Date;
    lastModifiedBy: string | null;
    name: string;
    description: string;
    slug: string;
    banner: string | null;
    icon: string | null;
    body: string | null;
}

export class CategoryList implements ICategoryList {
    items!: Category[];
    pageNumber!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: ICategoryList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Category.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryList {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ICategoryList {
    items: Category[];
    pageNumber: number;
    totalPages: number;
    totalCount: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class CategoryRequest implements ICategoryRequest {
    name!: string | null;
    description!: string | null;
    slug!: string;
    banner!: string | null;
    icon!: string | null;
    body!: string | null;

    constructor(data?: ICategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface ICategoryRequest {
    name: string | null;
    description: string | null;
    slug: string;
    banner: string | null;
    icon: string | null;
    body: string | null;
}

export class CurrentSession implements ICurrentSession {
    email!: string;
    role!: string;

    constructor(data?: ICurrentSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
        }
    }

    static fromJS(data: any): CurrentSession {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        return data;
    }
}

export interface ICurrentSession {
    email: string;
    role: string;
}

export class Folder implements IFolder {
    id!: number;
    siteId!: number;
    created!: Date;
    createdBy!: string | null;
    lastModified!: Date;
    lastModifiedBy!: string | null;
    name!: string;
    slug!: string | null;
    accessRoles!: string | null;
    parentFolderId!: number | null;
    parentFolder!: Folder;
    subFolders!: Folder[];

    constructor(data?: IFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.accessRoles = _data["accessRoles"] !== undefined ? _data["accessRoles"] : <any>null;
            this.parentFolderId = _data["parentFolderId"] !== undefined ? _data["parentFolderId"] : <any>null;
            this.parentFolder = _data["parentFolder"] ? Folder.fromJS(_data["parentFolder"]) : <any>null;
            if (Array.isArray(_data["subFolders"])) {
                this.subFolders = [] as any;
                for (let item of _data["subFolders"])
                    this.subFolders!.push(Folder.fromJS(item));
            }
            else {
                this.subFolders = <any>null;
            }
        }
    }

    static fromJS(data: any): Folder {
        data = typeof data === 'object' ? data : {};
        let result = new Folder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["accessRoles"] = this.accessRoles !== undefined ? this.accessRoles : <any>null;
        data["parentFolderId"] = this.parentFolderId !== undefined ? this.parentFolderId : <any>null;
        data["parentFolder"] = this.parentFolder ? this.parentFolder.toJSON() : <any>null;
        if (Array.isArray(this.subFolders)) {
            data["subFolders"] = [];
            for (let item of this.subFolders)
                data["subFolders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFolder {
    id: number;
    siteId: number;
    created: Date;
    createdBy: string | null;
    lastModified: Date;
    lastModifiedBy: string | null;
    name: string;
    slug: string | null;
    accessRoles: string | null;
    parentFolderId: number | null;
    parentFolder: Folder;
    subFolders: Folder[];
}

export class FolderRequest implements IFolderRequest {
    name!: string;
    slug!: string | null;
    accessRoles!: string | null;
    parentFolderId!: number | null;

    constructor(data?: IFolderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.accessRoles = _data["accessRoles"] !== undefined ? _data["accessRoles"] : <any>null;
            this.parentFolderId = _data["parentFolderId"] !== undefined ? _data["parentFolderId"] : <any>null;
        }
    }

    static fromJS(data: any): FolderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FolderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["accessRoles"] = this.accessRoles !== undefined ? this.accessRoles : <any>null;
        data["parentFolderId"] = this.parentFolderId !== undefined ? this.parentFolderId : <any>null;
        return data;
    }
}

export interface IFolderRequest {
    name: string;
    slug: string | null;
    accessRoles: string | null;
    parentFolderId: number | null;
}

export class Message implements IMessage {
    id!: number;
    siteId!: number;
    name!: string;
    email!: string;
    body!: string;
    created!: Date;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        return data;
    }
}

export interface IMessage {
    id: number;
    siteId: number;
    name: string;
    email: string;
    body: string;
    created: Date;
}

export class MessageList implements IMessageList {
    items!: Message[];
    pageNumber!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: IMessageList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Message.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): MessageList {
        data = typeof data === 'object' ? data : {};
        let result = new MessageList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IMessageList {
    items: Message[];
    pageNumber: number;
    totalPages: number;
    totalCount: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class MessageRequest implements IMessageRequest {
    name!: string;
    email!: string;
    body!: string;

    constructor(data?: IMessageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): MessageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MessageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface IMessageRequest {
    name: string;
    email: string;
    body: string;
}

export class Post implements IPost {
    id!: number;
    siteId!: number;
    created!: Date;
    createdBy!: string | null;
    lastModified!: Date;
    lastModifiedBy!: string | null;
    title!: string;
    description!: string;
    slug!: string | null;
    author!: string;
    authorAvatar!: string | null;
    image!: string | null;
    ogImage!: string | null;
    ogTitle!: string | null;
    ogType!: string | null;
    body!: string;
    publishDate!: Date;
    isFeatured!: boolean;
    readonly tags!: string;
    categoryId!: number;
    category!: Category;

    constructor(data?: IPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.author = _data["author"] !== undefined ? _data["author"] : <any>null;
            this.authorAvatar = _data["authorAvatar"] !== undefined ? _data["authorAvatar"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.ogImage = _data["ogImage"] !== undefined ? _data["ogImage"] : <any>null;
            this.ogTitle = _data["ogTitle"] !== undefined ? _data["ogTitle"] : <any>null;
            this.ogType = _data["ogType"] !== undefined ? _data["ogType"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
            this.publishDate = _data["publishDate"] ? new Date(_data["publishDate"].toString()) : <any>null;
            this.isFeatured = _data["isFeatured"] !== undefined ? _data["isFeatured"] : <any>null;
            (<any>this).tags = _data["tags"] !== undefined ? _data["tags"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>null;
        }
    }

    static fromJS(data: any): Post {
        data = typeof data === 'object' ? data : {};
        let result = new Post();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        data["authorAvatar"] = this.authorAvatar !== undefined ? this.authorAvatar : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["ogImage"] = this.ogImage !== undefined ? this.ogImage : <any>null;
        data["ogTitle"] = this.ogTitle !== undefined ? this.ogTitle : <any>null;
        data["ogType"] = this.ogType !== undefined ? this.ogType : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>null;
        data["isFeatured"] = this.isFeatured !== undefined ? this.isFeatured : <any>null;
        data["tags"] = this.tags !== undefined ? this.tags : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        return data;
    }
}

export interface IPost {
    id: number;
    siteId: number;
    created: Date;
    createdBy: string | null;
    lastModified: Date;
    lastModifiedBy: string | null;
    title: string;
    description: string;
    slug: string | null;
    author: string;
    authorAvatar: string | null;
    image: string | null;
    ogImage: string | null;
    ogTitle: string | null;
    ogType: string | null;
    body: string;
    publishDate: Date;
    isFeatured: boolean;
    tags: string;
    categoryId: number;
    category: Category;
}

export class PostList implements IPostList {
    items!: Post[];
    pageNumber!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: IPostList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Post.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PostList {
        data = typeof data === 'object' ? data : {};
        let result = new PostList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IPostList {
    items: Post[];
    pageNumber: number;
    totalPages: number;
    totalCount: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class PostRequest implements IPostRequest {
    title!: string;
    description!: string;
    slug!: string | null;
    author!: string | null;
    authorAvatar!: string | null;
    image!: string | null;
    ogImage!: string | null;
    ogTitle!: string | null;
    ogType!: string | null;
    body!: string;
    publishDate!: Date | null;
    isFeatured!: boolean;
    categoryId!: number;
    tags!: string;

    constructor(data?: IPostRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.author = _data["author"] !== undefined ? _data["author"] : <any>null;
            this.authorAvatar = _data["authorAvatar"] !== undefined ? _data["authorAvatar"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.ogImage = _data["ogImage"] !== undefined ? _data["ogImage"] : <any>null;
            this.ogTitle = _data["ogTitle"] !== undefined ? _data["ogTitle"] : <any>null;
            this.ogType = _data["ogType"] !== undefined ? _data["ogType"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
            this.publishDate = _data["publishDate"] ? new Date(_data["publishDate"].toString()) : <any>null;
            this.isFeatured = _data["isFeatured"] !== undefined ? _data["isFeatured"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.tags = _data["tags"] !== undefined ? _data["tags"] : <any>null;
        }
    }

    static fromJS(data: any): PostRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PostRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        data["authorAvatar"] = this.authorAvatar !== undefined ? this.authorAvatar : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["ogImage"] = this.ogImage !== undefined ? this.ogImage : <any>null;
        data["ogTitle"] = this.ogTitle !== undefined ? this.ogTitle : <any>null;
        data["ogType"] = this.ogType !== undefined ? this.ogType : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>null;
        data["isFeatured"] = this.isFeatured !== undefined ? this.isFeatured : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["tags"] = this.tags !== undefined ? this.tags : <any>null;
        return data;
    }
}

export interface IPostRequest {
    title: string;
    description: string;
    slug: string | null;
    author: string | null;
    authorAvatar: string | null;
    image: string | null;
    ogImage: string | null;
    ogTitle: string | null;
    ogType: string | null;
    body: string;
    publishDate: Date | null;
    isFeatured: boolean;
    categoryId: number;
    tags: string;
}

export class Project implements IProject {
    id!: number;
    siteId!: number;
    created!: Date;
    createdBy!: string | null;
    lastModified!: Date;
    lastModifiedBy!: string | null;
    name!: string;
    description!: string;
    slug!: string | null;
    github!: string;
    demo!: string;
    image!: string | null;
    body!: string | null;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.github = _data["github"] !== undefined ? _data["github"] : <any>null;
            this.demo = _data["demo"] !== undefined ? _data["demo"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["github"] = this.github !== undefined ? this.github : <any>null;
        data["demo"] = this.demo !== undefined ? this.demo : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface IProject {
    id: number;
    siteId: number;
    created: Date;
    createdBy: string | null;
    lastModified: Date;
    lastModifiedBy: string | null;
    name: string;
    description: string;
    slug: string | null;
    github: string;
    demo: string;
    image: string | null;
    body: string | null;
}

export class ProjectList implements IProjectList {
    items!: Project[];
    pageNumber!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: IProjectList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Project.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): ProjectList {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface IProjectList {
    items: Project[];
    pageNumber: number;
    totalPages: number;
    totalCount: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class ProjectRequest implements IProjectRequest {
    name!: string;
    description!: string;
    slug!: string | null;
    github!: string | null;
    demo!: string | null;
    image!: string | null;
    body!: string | null;

    constructor(data?: IProjectRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.github = _data["github"] !== undefined ? _data["github"] : <any>null;
            this.demo = _data["demo"] !== undefined ? _data["demo"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): ProjectRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["github"] = this.github !== undefined ? this.github : <any>null;
        data["demo"] = this.demo !== undefined ? this.demo : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface IProjectRequest {
    name: string;
    description: string;
    slug: string | null;
    github: string | null;
    demo: string | null;
    image: string | null;
    body: string | null;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string;
    username!: string;
    password!: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IRegisterRequest {
    email: string;
    username: string;
    password: string;
}

export class Site implements ISite {
    id!: number;
    name!: string;
    slug!: string | null;
    description!: string;
    baseUrl!: string;
    created!: Date;
    createdBy!: string | null;
    lastModified!: Date;
    lastModifiedBy!: string | null;

    constructor(data?: ISite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.baseUrl = _data["baseUrl"] !== undefined ? _data["baseUrl"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
        }
    }

    static fromJS(data: any): Site {
        data = typeof data === 'object' ? data : {};
        let result = new Site();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["baseUrl"] = this.baseUrl !== undefined ? this.baseUrl : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        return data;
    }
}

export interface ISite {
    id: number;
    name: string;
    slug: string | null;
    description: string;
    baseUrl: string;
    created: Date;
    createdBy: string | null;
    lastModified: Date;
    lastModifiedBy: string | null;
}

export class SiteList implements ISiteList {
    items!: Site[];
    pageNumber!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: ISiteList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Site.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): SiteList {
        data = typeof data === 'object' ? data : {};
        let result = new SiteList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ISiteList {
    items: Site[];
    pageNumber: number;
    totalPages: number;
    totalCount: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class SiteRequest implements ISiteRequest {
    name!: string;
    description!: string;
    slug!: string | null;
    baseUrl!: string;

    constructor(data?: ISiteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.baseUrl = _data["baseUrl"] !== undefined ? _data["baseUrl"] : <any>null;
        }
    }

    static fromJS(data: any): SiteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SiteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["baseUrl"] = this.baseUrl !== undefined ? this.baseUrl : <any>null;
        return data;
    }
}

export interface ISiteRequest {
    name: string;
    description: string;
    slug: string | null;
    baseUrl: string;
}

export class Tag implements ITag {
    id!: number;
    siteId!: number;
    created!: Date;
    createdBy!: string | null;
    lastModified!: Date;
    lastModifiedBy!: string | null;
    name!: string;
    description!: string;
    slug!: string | null;
    icon!: string;
    banner!: string;
    body!: string | null;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface ITag {
    id: number;
    siteId: number;
    created: Date;
    createdBy: string | null;
    lastModified: Date;
    lastModifiedBy: string | null;
    name: string;
    description: string;
    slug: string | null;
    icon: string;
    banner: string;
    body: string | null;
}

export class TagList implements ITagList {
    items!: Tag[];
    pageNumber!: number;
    readonly totalPages!: number;
    readonly totalCount!: number;
    readonly hasPreviousPage!: boolean;
    readonly hasNextPage!: boolean;

    constructor(data?: ITagList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Tag.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            (<any>this).totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            (<any>this).totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            (<any>this).hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            (<any>this).hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): TagList {
        data = typeof data === 'object' ? data : {};
        let result = new TagList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export interface ITagList {
    items: Tag[];
    pageNumber: number;
    totalPages: number;
    totalCount: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class TagRequest implements ITagRequest {
    name!: string;
    description!: string;
    slug!: string | null;
    icon!: string | null;
    banner!: string | null;
    body!: string | null;

    constructor(data?: ITagRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.slug = _data["slug"] !== undefined ? _data["slug"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            this.banner = _data["banner"] !== undefined ? _data["banner"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): TagRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TagRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["slug"] = this.slug !== undefined ? this.slug : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        data["banner"] = this.banner !== undefined ? this.banner : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface ITagRequest {
    name: string;
    description: string;
    slug: string | null;
    icon: string | null;
    banner: string | null;
    body: string | null;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

/**
 * Configuration class needed in base class.
 * The config is provided to the API client at initialization time.
 * API clients inherit from #AuthorizedApiBase and provide the config.
 */
// export type ApiOptions = {
//     apiKey: string | undefined,
// };

export class ApiConfig {

    private _apiKey: string = "";

    constructor(apiKey: string | null = null, loggedOutCallback: (()=>void) | null = null) {
        if (apiKey != null) {
            this._apiKey = apiKey;
        }
        if (loggedOutCallback != null) {
            this.loggedOutCallback = loggedOutCallback;
        }
    }

    loggedOutCallback = () => {}

    isAnonymous() {
        return !this.isApiKeyAuth() && !this.isJwtAuth();
    }

    isApiKeyAuth() {
        return this._apiKey != "";
    }

    isJwtAuth() {
        return this.getAuthorization() != "";
    }
    /**
     * Returns a valid value for the Authorization header.
     * Used to dynamically inject the current auth header.
     */
    getAuthorization() {
        try {
            return ("Bearer " + localStorage.getItem('AdminAuthToken')) || "";
        } catch(e) {
        }
        return "";
    }

    getApiKey() {
        return this._apiKey;
    }
}

export function setAuthorizationToken(token: string | null) {
    if (token == null) {
        localStorage.removeItem('AdminAuthToken');
    } else {
        localStorage.setItem('AdminAuthToken', token);
    }
}